// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`

enum EegResolution {
  bits12,
  bits14,
  ;

  Future<double> offset() =>
      RustLib.instance.api.crateMuseTypesEegResolutionOffset(
        that: this,
      );

  Future<double> scaleFactor() =>
      RustLib.instance.api.crateMuseTypesEegResolutionScaleFactor(
        that: this,
      );
}

enum MuseModel {
  muse2016,
  muse2,
  museS,
  museSAthena,
  unknown,
  ;

  Future<BigInt> channelCount() =>
      RustLib.instance.api.crateMuseTypesMuseModelChannelCount(
        that: this,
      );

  Future<bool> hasFnirs() =>
      RustLib.instance.api.crateMuseTypesMuseModelHasFnirs(
        that: this,
      );

  Future<bool> hasPpg() => RustLib.instance.api.crateMuseTypesMuseModelHasPpg(
        that: this,
      );

  Future<BigInt> ppgChannelCount() =>
      RustLib.instance.api.crateMuseTypesMuseModelPpgChannelCount(
        that: this,
      );

  Future<EegResolution> resolution() =>
      RustLib.instance.api.crateMuseTypesMuseModelResolution(
        that: this,
      );
}

enum MusePacketType {
  eegPpg,
  imu,
  eeg,
  ppg,
  accel,
  gyro,
  fnirs,
  none,
  other,
  ;
}

class MuseProcessedData {
  final List<Float64List> eeg;
  final Float64List ppgIr;
  final Float64List ppgRed;
  final Float64List ppgNir;
  final double? spo2;
  final double? fnirsHbo2;
  final double? fnirsHbr;
  final double? fnirsTsi;
  final F64Array3 accel;
  final F64Array3 gyro;
  final double timestamp;
  final double battery;
  final List<MusePacketType> packetTypes;

  const MuseProcessedData({
    required this.eeg,
    required this.ppgIr,
    required this.ppgRed,
    required this.ppgNir,
    this.spo2,
    this.fnirsHbo2,
    this.fnirsHbr,
    this.fnirsTsi,
    required this.accel,
    required this.gyro,
    required this.timestamp,
    required this.battery,
    required this.packetTypes,
  });

  static Future<MuseProcessedData> default_() =>
      RustLib.instance.api.crateMuseTypesMuseProcessedDataDefault();

  @override
  int get hashCode =>
      eeg.hashCode ^
      ppgIr.hashCode ^
      ppgRed.hashCode ^
      ppgNir.hashCode ^
      spo2.hashCode ^
      fnirsHbo2.hashCode ^
      fnirsHbr.hashCode ^
      fnirsTsi.hashCode ^
      accel.hashCode ^
      gyro.hashCode ^
      timestamp.hashCode ^
      battery.hashCode ^
      packetTypes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MuseProcessedData &&
          runtimeType == other.runtimeType &&
          eeg == other.eeg &&
          ppgIr == other.ppgIr &&
          ppgRed == other.ppgRed &&
          ppgNir == other.ppgNir &&
          spo2 == other.spo2 &&
          fnirsHbo2 == other.fnirsHbo2 &&
          fnirsHbr == other.fnirsHbr &&
          fnirsTsi == other.fnirsTsi &&
          accel == other.accel &&
          gyro == other.gyro &&
          timestamp == other.timestamp &&
          battery == other.battery &&
          packetTypes == other.packetTypes;
}
